package agh.ii.prinjava.lab01.lst01_10;

import java.util.HashMap;
import java.util.Map;

/**
 * Notes regarding {@code toString}, {@code hashCode}, and {@code equals}:
 * <ul>
 *     <li>Always override toString
 *     <li>Always override hashCode when you override equals</li>
 *     <li>Always use {@code @Override} annotation in front of these methods</li>
 *     <li>The {@code equals} method implements an equivalence relation on non-null object references</li>
 *     <li>{@code if (o1.equals(o2)) then (hasCode(o1) == hashCode(o2))};
 *         of course, two unequal objects may have the same hash code</li>
 *     <li>It is very important that exactly the same set of properties is used for establishing equality
 *         in the {@code equals} method and for the hash calculation in the {@code hashCode} method</li>
 *     <li>The default (i.e., inherited from the {@code Object class}) implementation of {@code hashCode}
 *         uses object address, which is (in most cases) inefficient
 *         (every object goes to its own bucket)</li>
 *     <li>A correct implementation of {@code toString} in most cases is straightforward,
 *         but implementing {@code hashCode} and {@code equals} can be challenging
 *         (especially in the case of class hierarchies).
 *         Fortunately, their versions generated by IDEs are often "good enough"</li>
 * </ul>
 *
 * @see <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html">
 * Class Object</a>
 */
public class Main {
    private static boolean hashMapWorksForHashCodeProblemInstances() {
        Map<HashCodeProblem, String> items = new HashMap<>();
        items.put(new HashCodeProblem("abc", "ABC"), "123");
        items.put(new HashCodeProblem("def", "DEF"), "456");
        items.put(new HashCodeProblem("ghi", "GHi"), "789");

        // Now get the value corresponding to the ("abc", "ABC") key
        HashCodeProblem k1 = new HashCodeProblem("abc", "ABC");
        String valueForK1 = items.get(k1);
        return "123".equals(valueForK1);
    }

    private static boolean hashMapWorksForHashCodeOKInstances() {
        Map<HashCodeOK, String> items = new HashMap<>();
        items.put(new HashCodeOK("abc", "ABC"), "123");
        items.put(new HashCodeOK("def", "DEF"), "456");
        items.put(new HashCodeOK("ghi", "GHi"), "789");

        // Now get the value corresponding to the ("abc", "ABC") key
        HashCodeOK k1 = new HashCodeOK("abc", "ABC");
        String valueForK1 = items.get(k1);
        return "123".equals(valueForK1);
    }

    public static void main(String[] args) {
        if (!hashMapWorksForHashCodeProblemInstances()) {
            System.out.println("(1) Test failed: hashMap does not work for HashCodeProblemInstances");
        }

        if (!hashMapWorksForHashCodeOKInstances()) {
            System.out.println("(2) Test failed: hashMap does not work for HashCodeOKInstances");
        }
    }
}
